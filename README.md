# Sample_of_sequential_programming

## プロジェクトの設計思想と概要
本プロジェクトは、Pythonという高度に抽象化された動的言語を用いながら、産業用コントローラ（PLC）や組み込みシステムに見られる「逐次実行（シーケンシャルプログラミング）」と「状態中心設計」の概念を再構築する試みです。一般的なプログラムが関数呼び出しによる一時的なデータの「流れ」に依存するのに対し、本システムでは全ての情報を共有メモリ上の永続的な「状態」として定義します。これにより、処理の順序が物理的なバケツリレーのように明快になり、システム全体の挙動を極めて高い決定論に基づいて制御することが可能となっています。

## PKVFデータモデルによる仮想メモリマップ
システムの情報を整理するための基盤として、発行者（Publisher）、キー（Key）、値（Value）、フラグ（Flag）の四要素からなるPKVFモデルを採用しています。これはPythonの動的なメモリ空間の中に、あえて論理的な「番地」を定義する試みです。各スクリプトはこの共有メモリ空間をレジスタマップのように参照し、値の書き込みと同時にフラグを操作することで、後続プロセスに対して「処理可能」や「処理完了」といった信号を送ります。このハンドシェイク構造により、情報の生成から消費までのライフサイクルが透明化され、不確実なデータの競合を根底から排除しています。

## システム構成と各モジュールの責務
メインコントローラーである main.py は、個別の業務ロジックを持たず、登録されたスクリプトを順番に呼び出す実行環境に徹しています。このコントローラーは背後で threading を用いたメモリ共有サーバーを起動しており、メインのループがユーザー入力などで停止（ブロッキング）している間も、外部からのデータアクセスを許可し続けます。個別の機能は scripts ディレクトリ配下の独立した関数として実装され、それらが共有メモリという共通の「広場」を介してのみ通信することで、スクリプト間の疎結合性が保たれています。

## 観測可能性とデバッグ環境の革新
本プロジェクトの最大の特徴は、monitor.py による「外部からの状態監視」にあります。これはマイコン開発におけるメモリダンプやハードウェアデバッガーの機能をPython上に再実装したものです。データの変化があった瞬間のみをタイムスタンプ、発行者、キー、値、フラグの順で一行出力するイベントログ形式の表示により、システム内で起きた出来事を時系列に沿った「歴史」として観測できます。関数内部に隠蔽されがちな引数や返り値を、全て共有メモリ上の公開された状態へと引きずり出したことで、デバッグは「推測」から「事実の確認」へと進化しました。

## 外部プロセスによる動的介入と柔軟性
共有メモリを介した設計の副次的な効果として、稼働中のシステムに対する外部からの動的な介入が容易になっています。メインプロセスが入力待ちで止まっている間に、別の介入ツールから特定の変数（例えばハッシュ化に使用するソルト値など）を書き換えることで、プログラム本体のコードを一切変更することなく、実行時の挙動をリアルタイムに操作できます。この特性は、複雑なシステムのパラメータ調整や異常時の強制介入において絶大な威力を発揮します。抽象化の果てに失われがちな「確実な足場」を、あえて不自由な構造の中に再定義することこそが、本プロジェクトが提唱する新しい開発パラダイムです。